<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Manhattan Runs</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <style>
    :root { --run-orange: #ff6a00; }
    body { margin: 0; padding: 0; background: #000; }
    #map  { position: absolute; inset: 0; }

    /* miles counter overlay */
    #miles-counter{
      position: absolute; top: 14px; right: 14px; z-index: 10;
      pointer-events: none; color: var(--run-orange);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-weight: 800; font-size: 24px; line-height: 1;
      text-shadow: 0 1px 3px rgba(0,0,0,.65);
      letter-spacing: .3px; font-variant-numeric: tabular-nums; user-select: none;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="miles-counter" aria-label="Total miles run">To Date: —</div>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoidGhvdWxkZW4iLCJhIjoiY21jczl5Y3VqMTAweTJrczN5ajlpcXY2ciJ9.51bpDEgJ0f0i8QF-2Tlxtg';

    let manhattanBoundary = { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[]] } };
    let centralParkBoundary = null;

    // Load both boundaries, then (maybe) install the runs filter and init the map
    Promise.all([
      fetch('manhattan-boundary.json').then(r => r.json()).catch(() => null),
      fetch('central-park-boundary.json').then(r => r.json()).catch(() => null)
    ])
    .then(([mb, cp]) => {
      if (mb) manhattanBoundary = (mb.type === 'FeatureCollection') ? mb.features[0] : mb;
      if (cp) centralParkBoundary = (cp.type === 'FeatureCollection') ? cp.features[0] : cp;

      // Validate CP polygon area (~3.41 km^2). If absurdly large, skip filtering.
      let canFilter = false;
      if (centralParkBoundary && centralParkBoundary.geometry) {
        try {
          const areaM2 = turf.area(centralParkBoundary);
          console.log(`Central Park polygon area: ${(areaM2/1e6).toFixed(2)} km²`);
          if (areaM2 > 1e7) { // >10 km² → probably wrong polygon
            console.warn('CP boundary area looks too large; skipping filter.');
          } else {
            canFilter = true;
          }
        } catch (e) {
          console.warn('Could not compute CP area; skipping filter.', e);
        }
      } else {
        console.warn('Central Park boundary not loaded; runs will not be filtered.');
      }

      if (canFilter) installRunsFilter(centralParkBoundary);
      initializeMap(centralParkBoundary);
    })
    .catch(err => {
      console.error('Error loading boundaries:', err);
      initializeMap(null); // still initialize, just without CP overlay/filter
    });

    /**
     * Wrap window.fetch so requests for manhattan-runs.json return a filtered array
     * (exclude runs where >60% of sampled points fall inside Central Park).
     */
    function installRunsFilter(cpFeature) {
      const originalFetch = window.fetch.bind(window);
      const insideCP = (lngLat) => turf.booleanPointInPolygon(turf.point(lngLat), cpFeature);

      window.fetch = async (input, init) => {
        const url = (typeof input === 'string') ? input : input.url;
        // robust match (handles query strings like ?v=123)
        if (url && url.indexOf('manhattan-runs.json') !== -1) {
          const res = await originalFetch(input, init);
          const runs = await res.json();
          if (!Array.isArray(runs)) {
            return new Response(JSON.stringify(runs), { headers: { 'Content-Type': 'application/json' } });
          }

          let kept = 0, removed = 0;
          const filtered = runs.filter(run => {
            const coords = run.coordinates || [];
            if (coords.length === 0) { kept++; return true; }

            // Sample up to 200 evenly spaced points
            const step = Math.max(1, Math.floor(coords.length / 200));
            let insideCount = 0, sampleCount = 0;
            for (let i = 0; i < coords.length; i += step) {
              sampleCount++;
              if (insideCP(coords[i])) insideCount++;
            }
            const fracInside = insideCount / (sampleCount || 1);
            const keep = fracInside <= 0.60;
            keep ? kept++ : removed++;
            return keep;
          });

          console.log(`Runs filtered by CP: kept=${kept}, removed=${removed}`);
          if (filtered.length && removed) {
            // log a few fractions for sanity (non-PII)
            console.log('Example fractions inside CP (first 5 kept/removed):');
          }

          return new Response(JSON.stringify(filtered), { headers: { 'Content-Type': 'application/json' } });
        }
        return originalFetch(input, init);
      };
    }

    // === Miles counter (uses filtered runs thanks to the fetch shim) ===
    function renderMilesCounter() {
      const el = document.getElementById('miles-counter');
      fetch('manhattan-runs.json', { cache: 'no-store' })
        .then(r => r.json())
        .then(runs => {
          const totalMeters = runs.reduce((sum, run) => sum + (run.distance || 0), 0);
          const miles = totalMeters / 1609.344;
          const rounded = Math.round(miles);
          const formatted = rounded.toLocaleString(undefined, { maximumFractionDigits: 0 });
          el.textContent = `To Date: ${formatted} mi`;
        })
        .catch(() => { el.textContent = 'To Date: —'; });
    }

    const BASE_BEARING = 119;                             // your current bearing 
    const MOBILE_BEARING = (BASE_BEARING + 90) % 360;     // rotate +90° for phones

    function isPhoneLike() {
    // "coarse" pointer ≈ touch devices; cap width to avoid large tablets
    return window.matchMedia('(pointer:coarse) and (max-width: 820px)').matches;
    }

    
    function initializeMap(cpFeature) {
      const initialBearing = isPhoneLike() ? MOBILE_BEARING : BASE_BEARING;
      const map = new mapboxgl.Map({
        container: 'map',
        style: {
          version: 8,
          sources: { composite: { type: 'vector', url: 'mapbox://mapbox.mapbox-streets-v8' } },
          layers: [{ id: 'background', type: 'background', paint: { 'background-color': '#000000' } }]
        },
        center: [-73.944, 40.78],
        zoom: 11.75, minZoom: 10, maxZoom: 16, bearing: initialBearing
      });

      map.on('load', () => {
        map.addSource('manhattan-boundary', { type: 'geojson', data: manhattanBoundary });

        map.addLayer({
          id: 'roads-primary', type: 'line', source: 'composite', 'source-layer': 'road',
          filter: ['==', 'class', 'primary'],
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: { 'line-color': '#ffffff', 'line-width': { base: 1.5, stops: [[11, 1.5],[14, 3],[16, 6]] } }
        });

        map.addLayer({
          id: 'roads-secondary', type: 'line', source: 'composite', 'source-layer': 'road',
          filter: ['in', 'class', 'secondary', 'tertiary'],
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: { 'line-color': '#cccccc', 'line-width': { base: 1.5, stops: [[11, 1],[14, 2],[16, 4]] } }
        });

        map.addLayer({
          id: 'roads-street', type: 'line', source: 'composite', 'source-layer': 'road',
          filter: ['in', 'class', 'street', 'street_limited'], minzoom: 11,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: { 'line-color': '#999999', 'line-width': { base: 1.5, stops: [[11, .5],[14, 1],[16, 2]] } }
        });

        // Mask outside Manhattan
        map.addLayer({
          id: 'mask-outside-manhattan', type: 'fill',
          source: {
            type: 'geojson',
            data: {
              type: 'Feature',
              geometry: {
                type: 'Polygon',
                coordinates: [
                  [[-84.5, 30.4], [-84.5, 51.0], [-63.4, 51.0], [-63.4, 30.4], [-84.5, 30.4]],
                  manhattanBoundary.geometry.coordinates[0]
                ]
              }
            }
          },
          paint: { 'fill-color': '#000000', 'fill-opacity': 1 }
        });

        // Central Park overlay (debug/visual confirmation)
        if (cpFeature) {
          map.addSource('central-park', { type: 'geojson', data: cpFeature });
          map.addLayer({
            id: 'central-park-fill',
            type: 'fill',
            source: 'central-park',
            paint: { 'fill-color': '#2ecc71', 'fill-opacity': 0.0 }
          });
        }

        // Logo overlay
        map.addSource('logo-overlay', {
          type: 'image',
          url: 'logo/manhattan-runs-logo-leftalign.png',
          coordinates: [
            [-73.835, 40.844], [-73.892, 40.766], [-73.943, 40.788], [-73.884, 40.867]
          ]
        });
        map.addLayer({
          id: 'logo-raster', type: 'raster', source: 'logo-overlay',
          paint: { 'raster-opacity': 1, 'raster-fade-duration': 0 }
        });

        const bounds = [[-74.02, 40.69], [-73.91, 40.88]];
        map.fitBounds(bounds, { center: [-73.944, 40.78], zoom: 11.75, padding: 50, bearing: initialBearing });

        // Load integration AFTER fetch shim
        const script = document.createElement('script');
        script.src = 'strava-integration.js';
        script.onload = () => {
          window.stravaIntegration = new StravaIntegration(map, manhattanBoundary);
          renderMilesCounter(); // reads filtered runs
        };
        document.head.appendChild(script);
      });
    }
  </script>
</body>
</html>

